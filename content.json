{"meta":{"title":"haolizi","subtitle":"欢迎来到我的个人博客","description":null,"author":"Haochuang","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2017-04-10T13:22:37.000Z","updated":"2017-04-18T06:11:29.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我，一名iOS开发工程师"},{"title":"根据标签快速定位","date":"2017-04-10T05:14:42.000Z","updated":"2017-04-11T03:15:44.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ReactiveCocoa入门<三> —— RAC常用方法","slug":"ReactiveCocoa入门-三","date":"2017-04-22T09:52:07.000Z","updated":"2017-05-23T10:17:57.000Z","comments":true,"path":"2017/04/22/ReactiveCocoa入门-三/","link":"","permalink":"http://yoursite.com/2017/04/22/ReactiveCocoa入门-三/","excerpt":"","text":"信号操作 映射 组合 过滤 条件 切片 线程 时间 重复 节流 映射 map：对源信号发出的数据做修改，传入一个block，类型是返回对象，参数是value，不用包装成信号，直接返回修改后的数据。 flattenMap：用于信号中信号，当源信号发出数据时，返回一个新的信号，但是订阅者收到的是返回信号中的值，信号可以是任意类型。12345678910111213141516171819202122232425262728/* map操作示例 1.传入一个block，类型是返回对象，参数是value 2.value就是源信号的内容，直接拿到源信号的内容做处理 3.把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值*/[[self.accountTextField.rac_textSignal map:^id(id value) &#123; //当源信号发出，就会调用这个block，修改源信号的内容 //返回值：就是处理完源信号的内容 return [NSString stringWithFormat:@\"输出:%@\",value];&#125;] subscribeNext:^(id x) &#123; NSLog(@\"结果:%@\",x);&#125;];/* flattenMap操作示例 1.传入一个block，block类型是返回值RACStream，参数value 2.参数value就是源信号的内容，拿到源信号的内容做处理 3.包装成RACReturnSignal信号，返回出去。*/[[_passwordTextField.rac_textSignal flattenMap:^RACStream *(id value) &#123; NSString *valueStr = [NSString stringWithFormat:@\"输出:%@\",value]; //记得导入头文件 #import &lt;ReactiveCocoa/RACReturnSignal.h&gt; return [RACReturnSignal return:valueStr];&#125;] subscribeNext:^(id x) &#123; //订阅信号，每当源信号发送内容，经过处理，就会调用这个block NSLog(@\"结果:%@\",x);&#125;]; 组合 concat then merge zipWith combineLatest reduce concat (组合、链接) -&gt; 按一定顺序拼接信号，当多个信号有可能发送数据的时候，按顺序进行接收。（每个都接收）-&gt; 借用个形象比喻，我们可以把各个信号理解成是皇上和太子关系，皇上君临天下、唯我独尊，一人独裁，谁敢抢皇上风头。只有当上一个信号（当前皇上）sendCompleted（驾崩）了则后一个信号（当前太子）变成新的皇上，它才能掌权，做自己想干的事，而驾崩的那位谁还理你。-&gt; 使用场景：有两部分数据，想让上部分先执行，完成之后再执行下部分（都能获取到值）123456789101112131415161718192021//创建信号ARACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@\"上部分数据\"]; [subscriber sendCompleted]; return nil;&#125;];//创建信号BRACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@\"下部分数据\"]; return nil;&#125;];//创建组合信号concat，按顺序去连接//注意第一个信号必须调用sendCompleted，第二个信号才会响应//（要不然当前皇上还健在，谁敢放肆）RACSignal *concat = [signalA concat:signalB];//订阅组合信号[concat subscribeNext:^(id x) &#123; //既能拿到A信号的值,又能拿到B信号的值 NSLog(@\"%@\", x);&#125;]; then（秩序）-&gt; 按一定顺序连接信号，当前一个信号完成，才会连接后一个信号。（只接收最后一个）-&gt; 可以理解成派一个team去完成一项任务，每人执行其中一个步骤，环环相扣，只需要关注最后一个人去执行的最后一步是否成功，若没有走到最后一步当然也是失败了。-&gt; 使用场景：有两部分数据：想让上部分先进行网络请求但是过滤掉数据，然后进行下部分的，拿到下部分数据123456789101112131415161718192021222324252627282930313233343536373839// 创建信号A RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@\"上部分数据\"]; [subscriber sendCompleted]; // 必须要调用sendCompleted方法！ return nil; &#125;]; // 创建信号B， RACSignal *signalsB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@\"下部分数据\"]; [subscriber sendCompleted]; return nil; &#125;]; // 创建组合信号 // then;忽略掉第一个信号的所有值 RACSignal *thenSignal = [signalA then:^RACSignal *&#123; // 返回的信号就是要组合的信号 return signalsB; &#125;]; // 订阅信号 [thenSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;];/*******************简写**********************/[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@\"上部分数据\"]; [subscriber sendCompleted]; return nil;&#125;] then:^RACSignal *&#123; return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@\"下部分数据\"]; return nil; &#125;];&#125;] subscribeNext:^(id x) &#123; //只能接收到第二个信号的值 NSLog(@\"\");&#125;]; merge（组合） 把多个信号合并为一个信号，任何一个信号有新值都会接收到。123456789101112131415161718// 创建信号A RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@\"上部分数据\"]; return nil; &#125;]; // 创建信号B， RACSignal *signalsB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@\"下部分数据\"]; return nil; &#125;]; //组合信号 RACSignal *mergeSignal = [signalA merge:signalB]; // 订阅信号 [mergeSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; zipWith（压缩）把多个信号压缩成一个信号，只有当信号同时发出信号内容时，并且把信号的内容合并成一个元组，才会触发压缩流的next事件。12345678910111213141516171819RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1]; return nil;&#125;];RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@2]; return nil;&#125;];// 压缩信号A，信号BRACSignal *zipSignal = [signalA zipWith:signalB];[zipSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;];// 实现:// 1.定义压缩信号，内部就会自动订阅signalA，signalB// 2.每当signalA或者signalB发出信号，就会判断signalA，signalB有没有发出个信号，有就会把最近发出的信号都包装成元组发出。 combineLatest （组合）将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号12345678910111213141516171819RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1]; return nil;&#125;];RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@2]; return nil;&#125;];// 把两个信号组合成一个信号,跟zip一样，没什么区别RACSignal *combineSignal = [signalA combineLatestWith:signalB];[combineSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;];// 实现：// 1.当组合信号被订阅，内部会自动订阅signalA，signalB,必须两个信号都发出内容，才会被触发。// 2.并且把两个信号组合成元组发出。 reduce（归约）用于当信号发出的数据是一个元组时，把元组数据的值聚合成一个新的值。（转换数据格式）12345678910111213141516171819202122232425RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1]; return nil;&#125;];RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@2]; return nil;&#125;];// 聚合// 常见的用法，（先组合在聚合）。combineLatest:(id&lt;NSFastEnumeration&gt;)signals reduce:(id (^)())reduceBlock// reduce中的block简介:// reduceblcok中的参数，有多少信号组合，reduceblcok就有多少参数，每个参数就是之前信号发出的内容// reduceblcok的返回值：聚合信号之后的内容。RACSignal *reduceSignal = [RACSignal combineLatest:@[signalA,signalB] reduce:^id(NSNumber *num1 ,NSNumber *num2)&#123; return [NSString stringWithFormat:@\"%@ %@\",num1,num2];&#125;];[reduceSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\",x);&#125;];// 实现:// 订阅聚合信号，每次有内容发出，就会执行reduceblcok，把信号内容转换成reduceblcok返回的值。 过滤 filter（过滤） ignore（忽略） 12345678910111213141516//filter过滤掉不需要的信号[_textField.rac_textSignal filter:^BOOL(NSString *value) &#123; return value.length &gt; 3;&#125;] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;];//ignore忽略掉某些值的信号//ignoreValues:表示忽略所有的值，只取Comletion和Error两个消息RACSubject *subject = [RACSubject subject];//ignoreValues:表示忽略所有的值RACSignal *ignoreSignal = [subject ignore:@2]; [ignoreSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; [subject sendNext:@2]; 条件 distinctUntilChanged take takeLast takeUntil skip switchToLatest distinctUntilChanged它将这一次的值与上一次做比较，当相同时（也包括 - isEqual: ）被忽略掉。1234//例如label绑定一个值RAC(self.label, text) = [RACObserve(self.user, username) distinctUntilChanged];self.user.username = @\"RAC\"; // 1stself.user.username = @\"RAC\"; // 2nd take从开始一共取N次的next值，不包括Competion和Error123456789[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;[subscriber sendNext:@&quot;1&quot;];[subscriber sendNext:@&quot;2&quot;];[subscriber sendNext:@&quot;3&quot;];[subscriber sendCompleted];return nil;&#125;] take:2] subscribeNext:^(id x) &#123;//取前两次的值NSLog(@&quot;only 1 and 2 will be log: %@&quot;, x);&#125;]; takeLast取最后N次的next值，注意，由于一开始不能知道这个Signal将有多少个next值，所以RAC实现它的方法是将所有next值都存起来，然后原Signal完成时再将后N个依次发送给接收者，但Error发生时依然是立刻发送的。（前提条件：信号必须发送完成） takeUntil一直取值直到遇到某个信号，比如UITextField的rac_textSignal skip从开始跳过几个信号 switchToLatest有时候信号发出的数据本身也是信号，即signalOfSignals，获取子信号中发出的数据 切片 线程 时间 重复 节流","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"ReactiveCocoa","slug":"ReactiveCocoa","permalink":"http://yoursite.com/tags/ReactiveCocoa/"}]},{"title":"ReactiveCocoa入门<二> —— RACSignal与RACSubject","slug":"ReactiveCocoa入门-二","date":"2017-04-14T06:49:13.000Z","updated":"2017-05-11T07:29:54.000Z","comments":true,"path":"2017/04/14/ReactiveCocoa入门-二/","link":"","permalink":"http://yoursite.com/2017/04/14/ReactiveCocoa入门-二/","excerpt":"","text":"RACSignal与RACSubjectRACSignal如何导入这里就不说了，你可以使用CocoaPods导入（推荐），也可以从github上下载导入。上文说道RAC最核心的类RACSignal，如果把RACSignal弄明白，基本上就可以使用RAC进行开发了，RACSignal到底是个什么东西呢，别急，切听我细细道来。RACSignal 是一个信号类，信号是数据流，可以被绑定和传递。它本身并不具备发送信号的能力，默认的一个信号都是冷信号，即使值改变了，也不会触发，只有订阅了这个信号（subscribeNext），才会变成热信号，当值改变时就会触发，发送信号。signal发送事件流给它的subscriber。主要有三种类型的事件：next、error、complete，今天主讲next事件简单范例如下：123456789101112131415161718192021222324252627//1.创建信号，把didSubscribe保存到信号中，信号被订阅时才会激活RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //subscriber：订阅者 //2.发送信号 [subscriber sendNext:value]; // 发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。 [subscriber sendCompleted]; //disposable：取消订阅或者清理资源 //当信号发送完成或者发送错误，就会执行这个block，取消订阅信号。 return [RACDisposable disposableWithBlock:^&#123; NSLog(@\"信号被销毁，当前信号不再被订阅\"); &#125;];&#125;];// 3.订阅信号，信号被激活.[siganl subscribeNext:^(id x) &#123; NSLog(@\"接收到数据:%@\",x);&#125;];## 具体底层实现1.创建信号，首先把didSubscribe保存到信号中，还未触发。2.当信号被订阅，就调用signal的subscribeNext:nextBlock 2.1 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。 2.2 subscribeNext内部会调用siganl的didSubscribe3.siganl的didSubscribe中调用[subscriber sendNext:value]; 3.1 sendNext底层其实就是执行subscriber的nextBlock 执行顺序如图： RACSubjectRACSubject 信号提供者，自己可以充当信号，又能发送信号，通常用来代替代理。简单范例如下：123456789101112131415// 1.创建信号，跟signal有点区别RACSubject *subject = [RACSubject subject];// 2.订阅信号[subject subscribeNext:^(id x) &#123; // block:当有数据发出的时候就会调用 NSLog(@\"%@\",x);&#125;];[subject subscribeNext:^(id x) &#123; // 第二个订阅者 NSLog(@\"%@\",x);&#125;];// 3.发送信号[subject sendNext:value]; 代替代理一、创建两个VC，这里分别用FirstVC和SecondVC代替，在SecondVC的.h中声明一个全局的信号：1@property (nonatomic, strong) RACSubject *signal; 二、在SecondVC.m中，将以下代码添加到需要传值的方法里：123if (self.subject) &#123; [self.subject sendNext:value];&#125; 三、在FirstVC跳转界面的方法里添加如下代码：1234567891011// 创建控制器SecondVC *secondVC = [[SecondVC alloc] init]; // 设置代理信号 secondVC.subject = [RACSubject subject]; // 订阅代理信号 [secondVC.subject subscribeNext:^(id x) &#123; NSLog(@\"回调的值：%@\", x);&#125;];// 跳转界面[self.navigationController pushViewController:secondVC animated:YES]; 是不是很简单？那么subject跟signal有什么不同呢？subject自己可以充当信号也可以发送消息，跟signal调用顺序一样，但是可以创建多个订阅者，并发送信号提到subject，就顺便说说它的子类replaySubject：RACReplaySubject 从字面上我们应该可以看出它是重复提供信号类，简单范例如下：12345678910111213141516// 创建信号RACReplaySubject *replaySubject = [RACReplaySubject subject];// 发送信号[replaySubject sendNext:value1];[replaySubject sendNext:value2];// 订阅信号1[replaySubject subscribeNext:^(id x) &#123; NSLog(@\"订阅信号1接收到数据%@\",x);&#125;];// 订阅信号2[replaySubject subscribeNext:^(id x) &#123; NSLog(@\"订阅信号2接收到的数据%@\",x);&#125;]; 看出来replaySubject与subject的区别了吗？replaySubject可以先发送信号，再订阅信号，但subject不行，subject必须先订阅信号，才能激活信号，然后发送的信号才能被接收到。那么这两个信号类分别在什么情况下使用呢？如果一个信号每被订阅一次就需要重复发送一遍之前的值，就使用replaySubject，其他的按照你实际情况各取所需。 文中多次出现RACSubscriber与RACDisposable这两个类，那么它们究竟是干嘛的呢？ RACSubscriber:表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。 RACDisposable:用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。 下篇我将分享ReactiveCocoa的常用操作","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"ReactiveCocoa","slug":"ReactiveCocoa","permalink":"http://yoursite.com/tags/ReactiveCocoa/"}]},{"title":"ReactiveCocoa入门<一> —— ReactiveCocoa简介","slug":"ReactiveCocoa入门-一","date":"2017-04-13T07:22:09.000Z","updated":"2017-05-12T02:31:58.000Z","comments":true,"path":"2017/04/13/ReactiveCocoa入门-一/","link":"","permalink":"http://yoursite.com/2017/04/13/ReactiveCocoa入门-一/","excerpt":"","text":"在开始正文之前，先简单谈谈编程思想 面向过程与面向对象面向过程：面向过程是一种以事件、以过程为中心的编程思想，自顶向下顺序执行，逐步求精，就像一个细心的管家，事无具细都要考虑到。面向对象：万物皆对象，它是将事物高度抽象化，就像个电器，只需要知道功能就可以了，不需要知道它的工作原理。面向对象三大特点：继承、封装、多态。这里只是简单打比方进行一下区别对比，想要了解更精细，请自行Google 链式编程思想：将多个操作（多行代码）通过点号（.）链接在一起成为一句代码，提高代码可读性。特点：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值），如果不太明白，请参考masonry框架。 响应式编程思想：不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。比如KVO的运用。 函数式编程思想：是把操作尽量写成一系列嵌套的函数或者方法调用。特点：每个方法必须有返回值（本身对象），把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果）正文ReactiveCocoa简介ReactiveCocoa（简称为RAC），是由Github开源的一个应用于iOS和OS开发的新框架。ReactiveCocoa作用 我们在iOS开发时，有着各种消息响应、传递机制，包括 KVO、block、Notification、delegation、属性变化、网络请求以及target-action方式等。 这些都可以通过RAC处理，RAC为事件提供了很多处理方法，大量使用block，更加方便，可以把代码写在一起，方便管理。符合我们开发追求的高聚合，低耦合的思想。 ReactiveCocoa结合了函数式编程（Functional Programming）、响应式编程（Reactive Programming）等编程思想，所以有人描述RAC为函数响应式编程（FRP）框架。 使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理，不仅是这些，它还提供给你轻松转换/分解/合并/过滤信息的能力，爽的不要不要的。 不过万物分阴阳，有得必有失，如果我们太过依赖于第三方框架，当它不随潮流更新或者彻底废弃了，那后期维护项目时就尴尬了，所以我们最好先了解清楚它的编程思想和设计理念、然后再决定取舍。 RAC最核心的类RACSignal，放在下篇分享。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"ReactiveCocoa","slug":"ReactiveCocoa","permalink":"http://yoursite.com/tags/ReactiveCocoa/"}]},{"title":"安装Homebrew","slug":"安装homebrew","date":"2017-04-08T10:28:27.000Z","updated":"2017-04-10T15:42:15.000Z","comments":true,"path":"2017/04/08/安装homebrew/","link":"","permalink":"http://yoursite.com/2017/04/08/安装homebrew/","excerpt":"","text":"Homebrew官网 Homebrew是干啥的Homebrew简称brew，是Mac OSX上的软件管理工具，能在Mac终端快速安装或卸载软件，类似于linux系统中的apt-get、yum神器。Homebrew是基于Ruby的，Mac默认安装有Ruby，所以安装过程比较简单。 Homebrew安装，一行命令搞定1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 如果地址不可用，可能是被墙了，多试几次，或者Google一些第三方的地址试试。 Homebrew常用命令（下面**代表你想操作的对象） brew –help 简洁命令帮助 man brew 完整命令帮助 brew list 显示已经安装的所有软件包 brew search ** 搜索 brew info ** 查询 brew install ** 安装 brew uninstall ** 卸载 brew outdated 检查是否有新版本 brew update 更新 brew upgrade 升级所有可以升级的软件 brew cleanup 清理所有已安装软件包的历史老版本等等。 你有没有感觉到自己的终端既丑又不灵活？接下来我会给大家分享如何安装iTerm及其主题","categories":[],"tags":[{"name":"homebrew","slug":"homebrew","permalink":"http://yoursite.com/tags/homebrew/"}]},{"title":"Mac下利用Hexo+GitHub搭建自己的博客","slug":"Mac下利用Hexo+GitHub搭建自己的博客","date":"2017-04-07T08:34:16.000Z","updated":"2017-04-11T09:33:38.000Z","comments":true,"path":"2017/04/07/Mac下利用Hexo+GitHub搭建自己的博客/","link":"","permalink":"http://yoursite.com/2017/04/07/Mac下利用Hexo+GitHub搭建自己的博客/","excerpt":"","text":"大家都说没有自己博客的程序员不是好程序员，以前经常活跃在CSDN和简书上，今天抽空整了一下Hexo+GitHub，如果你不舍得买服务器和域名的话，选择这个方式还是挺不错的，下面就把自己的操作步骤跟大家分享一下。 前期准备 首先你要有个github账号，如果还未注册，先去官网注册Github 第二步你要安装有Homebrew，当然其他方式也可以，这里只介绍使用Homebrew进行安装，如果你还未安装Homebrew，请参考我的下篇文章Homebrew的安装与使用 安装node.js和hexo 安装安装node.js1brew install node 安装hexo1sudo npm install -g hexo 初始化hexo1hexo init 创建文件夹123mkdir blog cd blog hexo init 前往blog目录下，你会发现此时多了一些文件和文件夹，如下图所示： 生成一套静态网页1hexo generate 在服务器上运行1hexo server 然后浏览器输入：localhost:4000，试试能不能打开，有没有很神奇？ 配置GitHub建立Repository前往github，建立对应的仓库，命名规则必须是“your_name.github.io”，your_name是你github对应的name 建立关联执行命令1vim _config.yml 找到[deploy],修改成如下样式：123type: gitrepo: https://github.com/your_name/your_name.github.io.gitbranch: master 然后执行命令：1npm install hexo-deployer-git --save 或者直接前往/Users/leopard/blog文件夹，找到_config.yml，进行修改执行命令hexo server启动服务，浏览器输入your_name.github.io，试下能否访问，咦，是不是又神奇了一次？先别太过激动，没听说过压轴戏通常都在后面吗？下面我将介绍常用命令的使用及主题clone。 常用命令hexo new post “postName” 新建文章hexo new page”pageName” 新建页面hexo generate 生成静态界面至public目录hexo deploy 将.deploy目录部署到GitHubhexo help 查看帮助hexo version 查看Hexo的版本等等 每次部署完，记得执行以下三个命令：123hexo cleanhexo ghexo d 例：新建文章1hexo new post &quot;我也有自己的博客了&quot; 找到~/blog/source/_posts/我也有自己的博客了.md 并打开进行编写：123title: 博文标题date: 创作博文的时间tags: 博文的标签 自行扩展，添加如下键值：1234update: 最后修改的时间comments: 能否评论此博文(默认为true)categories: 定义了博文的种类等。 执行命令clean、g和d，刷新浏览器，怎么样？有没有很有成就感？ 主题clone你可能会感觉别人的博客各种炫酷，而自己的丑到没朋友，别怕接下来将教你如何clone主题，以博主使用的next主题为例： 执行命令1git clone https://github.com/iissnan/hexo-theme-next themes/next 我们还需要修改_config.yml文件中的一处来应用新的主题1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: next 记得每次修改完_config.yml文件，都要重启服务hexo server。next主题具体设置请前往自行查看NexT主题。更多主题推荐：hexo主题推荐令：图文并茂的博文除了美观之外，更能清晰的表达作者的描述，可图片怎么处理呢？我的图片上传到了七牛，大家也可以点击注册七牛免费注册。 上传图片到七牛有多种方式，可以通过接口上传，也可以通过可视化工具，这里推荐一款Chrome的扩展程序qiniu upload files，使用很简单，直接拖拽即可，配置如下图：当然你也可以使用hexo插件，自动帮你将本地目录的文件同步到七牛，比如：hexo-qiniu-sync七牛免费空间比较小，所以上传图片前最好先把图片压缩一下，推荐个在线压缩工具：https://tinypng.com/","categories":[],"tags":[{"name":"Hexo+GitHub","slug":"Hexo-GitHub","permalink":"http://yoursite.com/tags/Hexo-GitHub/"}]}]}